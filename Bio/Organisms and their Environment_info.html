<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AquaGlass Viewer</title>
    <style>
        :root {
            /* Theme Variables */
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            --neon-blue: #00f2ff;
            --deep-water: #004e92;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(to bottom, #000428, #004e92);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        /* --- Animated Background "Water" --- */
        .water-bg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
            overflow: hidden;
        }
        .bubble {
            position: absolute;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1), rgba(255,255,255,0));
            border-radius: 50%;
            filter: blur(5px);
            animation: floatUp linear infinite;
        }
        @keyframes floatUp {
            0% { transform: translateY(120vh) scale(0.5); opacity: 0; }
            50% { opacity: 0.5; }
            100% { transform: translateY(-20vh) scale(1.5); opacity: 0; }
        }

        /* --- Main Glass Container --- */
        .glass-frame {
            position: relative;
            z-index: 10;
            width: 95vw;
            height: 90vh;
            background: var(--glass-bg);
            /* The Frost Effect */
            backdrop-filter: blur(15px); 
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            box-shadow: var(--glass-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Canvas Area --- */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab; /* Default cursor */
            background: rgba(0,0,0,0.2);
        }
        
        /* When drawing mode is active, we force this cursor via JS, 
           but having the class helps with specificity */
        #canvas-container.drawing {
            cursor: crosshair !important;
        }
        
        canvas {
            display: block;
            outline: none;
        }

        /* --- Floating UI Controls --- */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            padding: 10px 25px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: transform 0.2s;
        }

        .btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .btn:hover {
            background: rgba(255,255,255,0.1);
            color: white;
            transform: translateY(-5px);
        }

        .btn.active {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        /* Divider in toolbar */
        .sep { width: 1px; background: rgba(255,255,255,0.2); margin: 0 5px; }

        /* Color Picker Styling */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: none;
            cursor: pointer;
            padding: 0;
            overflow: hidden;
            transition: transform 0.2s;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid white; border-radius: 50%; }
        input[type="color"]:hover { transform: scale(1.1); }

        /* Loader */
        .loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: pulse 2s infinite;
            pointer-events: none;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; text-shadow: 0 0 20px var(--neon-blue); } 100% { opacity: 0.5; } }

    </style>
</head>
<body>

    <!-- 1. Background Animation -->
    <div class="water-bg" id="bg-effects"></div>

    <!-- 2. Main Application -->
    <div class="glass-frame">
        <div id="loading-text" class="loader">Loading Image...</div>
        
        <div id="canvas-container">
            <canvas id="viewer"></canvas>
        </div>

        <!-- Toolbar -->
        <div class="controls">
            <button class="btn active" id="tool-pan" title="Pan / Move (Spacebar)">
                <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M5 9l-3 3 3 3M9 5l3-3 3 3M19 9l3 3-3 3M9 19l3 3 3-3M2 12h20M12 2v20"/></svg>
            </button>
            
            <button class="btn" id="tool-draw" title="Annotate (P)">
                <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path></svg>
            </button>

            <div class="sep"></div>

            <input type="color" id="color-picker" value="#00f2ff" title="Ink Color">
            
            <div class="sep"></div>

            <button class="btn" id="action-reset" title="Reset View">
                <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
            
            <button class="btn" id="action-save" title="Download Image">
                <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            </button>
        </div>
    </div>

    <script>
        /**
         * ------------------------------------------------------------------
         * ADMIN CONFIGURATION
         * Replace this URL with your image source.
         * ------------------------------------------------------------------
         */
        const IMG_URL = "ch18-infographic.png"; 

        // --- Setup Variables ---
        const canvas = document.getElementById('viewer');
        const ctx = canvas.getContext('2d', { alpha: false });
        const container = document.getElementById('canvas-container');
        const loader = document.getElementById('loading-text');

        // Buttons
        const btnPan = document.getElementById('tool-pan');
        const btnDraw = document.getElementById('tool-draw');
        const colorInput = document.getElementById('color-picker');

        // State
        const image = new Image();
        let isLoaded = false;
        let scale = 1;
        let pX = 0; // Pan X
        let pY = 0; // Pan Y
        
        let isDragging = false;
        let isDrawing = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let currentTool = 'pan'; // 'pan' or 'draw'

        let annotations = [];
        let currentStroke = null;
        let brushColor = '#00f2ff';
        let brushWidth = 4;

        // --- Initialization ---

        // Generate Background Bubbles
        const bg = document.getElementById('bg-effects');
        for(let i=0; i<15; i++){
            let b = document.createElement('div');
            b.className = 'bubble';
            let size = Math.random() * 60 + 20;
            b.style.width = size + 'px';
            b.style.height = size + 'px';
            b.style.left = Math.random() * 100 + '%';
            b.style.animationDuration = (Math.random() * 10 + 5) + 's';
            b.style.animationDelay = (Math.random() * 5) + 's';
            bg.appendChild(b);
        }

        // Load Image
        image.src = IMG_URL;
        image.crossOrigin = "Anonymous";
        image.onload = () => {
            isLoaded = true;
            loader.style.display = 'none';
            resize();
            resetView();
        };

        window.addEventListener('resize', () => { resize(); draw(); });
        function resize() {
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
        }

        // --- Core Rendering ---

        function draw() {
            ctx.fillStyle = "#1a1a2e"; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!isLoaded) return;

            ctx.save();
            ctx.translate(pX, pY);
            ctx.scale(scale, scale);

            // Draw Image Centered
            const drawX = -image.width / 2;
            const drawY = -image.height / 2;
            ctx.drawImage(image, drawX, drawY);

            // Draw Annotations
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const renderPath = (stroke) => {
                if(stroke.points.length < 1) return;
                ctx.beginPath();
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.width; 
                ctx.moveTo(stroke.points[0].x + drawX, stroke.points[0].y + drawY);
                for(let i=1; i<stroke.points.length; i++){
                    ctx.lineTo(stroke.points[i].x + drawX, stroke.points[i].y + drawY);
                }
                ctx.stroke();
            };

            annotations.forEach(renderPath);
            if(currentStroke) renderPath(currentStroke);

            ctx.restore();
        }

        // --- Tool Logic ---

        function setTool(tool) {
            currentTool = tool;
            
            // Toggle Button Classes
            if(tool === 'pan') {
                btnPan.classList.add('active');
                btnDraw.classList.remove('active');
                
                // CURSOR LOGIC FOR PAN
                container.classList.remove('drawing');
                container.style.cursor = 'grab'; 
            } else {
                btnDraw.classList.add('active');
                btnPan.classList.remove('active');
                
                // CURSOR LOGIC FOR DRAW
                container.classList.add('drawing');
                container.style.cursor = 'crosshair';
            }
        }

        btnPan.addEventListener('click', () => setTool('pan'));
        btnDraw.addEventListener('click', () => setTool('draw'));
        colorInput.addEventListener('input', (e) => {
            brushColor = e.target.value;
            setTool('draw'); 
        });

        // --- Mouse Interaction ---

        function toImageCoords(cx, cy) {
            let x = cx - pX;
            let y = cy - pY;
            x /= scale;
            y /= scale;
            x += image.width / 2;
            y += image.height / 2;
            return { x, y };
        }

        container.addEventListener('mousedown', (e) => {
            if(e.button !== 0) return; 

            if (currentTool === 'pan') {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                container.style.cursor = 'grabbing'; // Grabbing effect
            } else if (currentTool === 'draw') {
                isDrawing = true;
                const pt = toImageCoords(e.offsetX, e.offsetY);
                currentStroke = {
                    color: brushColor,
                    width: brushWidth / scale,
                    points: [pt]
                };
                draw();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging && currentTool === 'pan') {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                pX += dx;
                pY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                draw();
            } else if (isDrawing && currentTool === 'draw') {
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pt = toImageCoords(x, y);
                currentStroke.points.push(pt);
                draw();
            }
        });

        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                // Return to 'grab' if we are still in pan mode
                if (currentTool === 'pan') container.style.cursor = 'grab';
            }
            if (isDrawing) {
                isDrawing = false;
                if(currentStroke) {
                    annotations.push(currentStroke);
                    currentStroke = null;
                }
                draw();
            }
        });

        // Zoom
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const direction = e.deltaY < 0 ? 1 : -1;
            const factor = 1 + (zoomIntensity * direction);

            const mouseX = e.offsetX;
            const mouseY = e.offsetY;
            const worldX = (mouseX - pX) / scale;
            const worldY = (mouseY - pY) / scale;

            const newScale = scale * factor;
            if(newScale < 0.1 || newScale > 50) return;
            scale = newScale;

            pX = mouseX - worldX * scale;
            pY = mouseY - worldY * scale;

            draw();
        }, { passive: false });

        // Reset
        document.getElementById('action-reset').addEventListener('click', resetView);
        function resetView() {
            if(!isLoaded) return;
            const scaleX = canvas.width / image.width;
            const scaleY = canvas.height / image.height;
            scale = Math.min(scaleX, scaleY) * 0.9;
            pX = canvas.width / 2;
            pY = canvas.height / 2;
            draw();
        }

        // Save
        document.getElementById('action-save').addEventListener('click', () => {
            const tCanvas = document.createElement('canvas');
            const tCtx = tCanvas.getContext('2d');
            tCanvas.width = image.width;
            tCanvas.height = image.height;

            tCtx.drawImage(image, 0, 0);
            tCtx.lineCap = 'round';
            tCtx.lineJoin = 'round';
            
            annotations.forEach(stroke => {
                tCtx.beginPath();
                tCtx.strokeStyle = stroke.color;
                tCtx.lineWidth = stroke.width; 
                if(stroke.points.length > 0) {
                    tCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                    for(let i=1; i<stroke.points.length; i++) {
                        tCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
                    }
                }
                tCtx.stroke();
            });

            const link = document.createElement('a');
            link.download = 'annotated_glass.png';
            link.href = tCanvas.toDataURL('image/png');
            link.click();
        });

    </script>
</body>
</html>
